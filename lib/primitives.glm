$ Option T
	| Some T
	| None
;
$ Result OkKind ErrKind
	| Ok OkKind
	| Err ErrKind
;

% Comment ;
:%?? Comment drop Option.None! Result.Ok! ;
:% Comment */ ( SingleVocabLifespan< Comment > -> ) drop ;
:% __@GLOBAL /*
	( -> SingleVocabLifespan< Comment > )
	Comment enter-single-vocabulary
;

/* Ahh, comments. Yep: gluumy's Vocabularies (TODO: should they be called
 * Modes? Like how Vim/Kakoune/Helix are "modal editors", gluumy is kinda
 * a "modal language") are so powerful, they can be used to implement core
 * language syntax that in many languages would be part of the "host"
 * language (or part of the compiler), and the implementations are even
 * type-safe (unlike, perhaps, FORTH's immediate words which can be used
 * to implement comments in many FORTH dialects).
 */

/* Docstrings are semantically-meaningful comments, in a sense: they are tied to
 * whatever object they reference as the first word, and will remain tied to that
 * object forever (see (TODO: WHERE?) for how the underlying runtime handles
 * this). There are very few semantically meaningful Words in docstrings - almost
 * everything is simply passed through to the underlying String object verbatim.
 * However, there's a few methods to reference other Words, Vocabularies, and
 * Shapes, and of course, the escape word.
 *
 * We'll abuse gluumy's lazy reference allowance here and refer to String, which
 * will be defined in a moment. As long as we don't attempt to actually use
 * Docstrings before String exists, we're safe: this does mean that String will
 * be the one Shape in this prelude where the docstring *follows* the
 * implementation. Whatever, man, rules are for squares.
 */
% Docstring ;
:%?? Docstring ( String )

$ String
	Comparable ..
	Equatable ..
	Printable ..
	DebugPrintable ..
	
	=> { __@PRIMITIVES } __@STRING ;
;
?$ String
	Contains a UTF-8 encoded string.
;

/* Alright. Order has been restored to the cosmos; docstrings will proceed
 * implementations now.
 */

?: swap
	Reverses the order of the top two items on the stack in-place. This
	operation happens in O(1) time. If fewer than two items are on the stack,
	the execution unit panics.
;
:!!! { __@PRIMITIVES } swap ( @1 @2 -> @2 @1 ) __@SWAP ;

?: rot
	Moves the third item (from the top) of the stack to the top, pushing the
	next two items down. This operation happens in O(1) time. If fewer than
	three items are on the stack, the execution unit panics.
;
:!!! { __@PRIMITIVES } rot ( @3 @2 @1 -- @2 @1 @3 ) __@ROT ;

?: drop
	Deletes the top item from the stack if it exists, or panics the execution
	unit. This operation happens in O(1) time.
;
:!!! { __@PRIMITIVES } drop ( @1 -> ) __@DROP ;

?: dup
	Creates another reference to the top item of the stack if it exists, or
	panics the execution unit. This operation happens in O(1) time: since 
	all values in gluumy are immutable, duplication just creates another
	pointer to the same underlying data, which does not itself need to be
	cloned.
	
	--
	
	TODO: An implementation-specific exception to this should be numbers, since
	a pointer to a usize is pretty silly.
;
:!!! { __@PRIMITIVES } dup ( @1 <- @1 ) __@DUP ;

?$ SignedInt
	Contains an unsigned integer that is the size of a pointer on the target
	platform (eg. on a 64-bit system, it is 64 bits / 8 bytes long).
;
$ SignedInt
	Comparable ..
	Equatable ..
	Printable ..
	DebugPrintable ..

	=> { __@PRIMITIVES } __@SIGNED_INT ;
;
:!!! { __@PRIMITIVES } eq ( SignedInt SignedInt <- Boolean ) __@EQ ;
:!!! { __@PRIMITIVES } gt ( SignedInt SignedInt <- Boolean ) __@GT ;
:!!! { __@PRIMITIVES } gte ( SignedInt SignedInt <- Boolean ) __@GTE ;
:!!! { __@PRIMITIVES } lt ( SignedInt SignedInt <- Boolean ) __@LT ;
:!!! { __@PRIMITIVES } lte ( SignedInt SignedInt <- Boolean ) __@LTE ;
:!!! { __@PRIMITIVES } repr ( SignedInt SignedInt <- String ) __@REPR ;
:!!! { __@PRIMITIVES } + ( SignedInt SignedInt -> SignedInt ) __@ADD ;
:!!! { __@PRIMITIVES } - ( SignedInt SignedInt -> SignedInt ) __@SUB ;
:!!! { __@PRIMITIVES } * ( SignedInt SignedInt -> SignedInt ) __@MUL ;

?$ UnsignedInt
	Contains an unsigned integer that is the size of a pointer on the target
	platform (eg. on a 64-bit system, it is 64 bits / 8 bytes long).
;
$ UnsignedInt
	Comparable ..
	Equatable ..
	Printable ..
	DebugPrintable ..

	=> { __@PRIMITIVES } __@UNSIGNED_INT;
;
:!!! { __@PRIMITIVES } eq ( UnsignedInt UnsignedInt <- Boolean ) __@EQ ;
:!!! { __@PRIMITIVES } gt ( UnsignedInt UnsignedInt <- Boolean ) __@GT ;
:!!! { __@PRIMITIVES } gte ( UnsignedInt UnsignedInt <- Boolean ) __@GTE ;
:!!! { __@PRIMITIVES } lt ( UnsignedInt UnsignedInt <- Boolean ) __@LT ;
:!!! { __@PRIMITIVES } lte ( UnsignedInt UnsignedInt <- Boolean ) __@LTE ;
:!!! { __@PRIMITIVES } repr ( UnsignedInt UnsignedInt <- String ) __@REPR ;
:!!! { __@PRIMITIVES } + ( UnsignedInt UnsignedInt -> UnsignedInt ) __@ADD ;
:!!! { __@PRIMITIVES } - ( UnsignedInt UnsignedInt -> UnsignedInt ) __@SUB ;
:!!! { __@PRIMITIVES } * ( UnsignedInt UnsignedInt -> UnsignedInt ) __@MUL;

?$ Float32
	Contains a 32-bit floating number (IEEE 754-2008's binary32 type).
;
$ Float32
	Equatable ..
	Printable ..
	DebugPrintable ..

	=> { __@PRIMITIVES } __@FLOAT32 ;
;
:!!! { __@PRIMITIVES } eq ( Float32 Float32 <- Boolean ) __@EQ ;
:!!! { __@PRIMITIVES } gt ( Float32 Float32 <- Boolean ) __@GT ;
:!!! { __@PRIMITIVES } gte ( Float32 Float32 <- Boolean ) __@GTE ;
:!!! { __@PRIMITIVES } lt ( Float32 Float32 <- Boolean ) __@LT ;
:!!! { __@PRIMITIVES } lte ( Float32 Float32 <- Boolean ) __@LTE ;
:!!! { __@PRIMITIVES } repr ( Float32 Float32 <- String ) __@REPR ;
:!!! { __@PRIMITIVES } + ( Float32 Float32 -> Float32 ) __@ADD ;
:!!! { __@PRIMITIVES } - ( Float32 Float32 -> Float32 ) __@SUB ;
:!!! { __@PRIMITIVES } * ( Float32 Float32 -> Float32 ) __@MUL ;
:!!! { __@PRIMITIVES } / ( Float32 Float32 -> Float32 ) __@DIV ;

?$ Float64
	Contains a 64-bit floating number (IEEE 754-2008's binary64 type).
;
$ Float64
	Equatable ..
	Printable ..
	DebugPrintable ..

	=> { __@PRIMITIVES } __@FLOAT64 ;
;
:!!! { __@PRIMITIVES } eq ( Float64 Float64 <- Boolean ) __@EQ ;
:!!! { __@PRIMITIVES } gt ( Float64 Float64 <- Boolean ) __@GT ;
:!!! { __@PRIMITIVES } gte ( Float64 Float64 <- Boolean ) __@GTE ;
:!!! { __@PRIMITIVES } lt ( Float64 Float64 <- Boolean ) __@LT ;
:!!! { __@PRIMITIVES } lte ( Float64 Float64 <- Boolean ) __@LTE ;
:!!! { __@PRIMITIVES } repr ( Float64 Float64 <- String ) __@REPR ;
:!!! { __@PRIMITIVES } + ( Float64 Float64 -> Float64 ) __@ADD ;
:!!! { __@PRIMITIVES } + ( Float32 Float64 -> Float64 ) __@ADD ;
:!!! { __@PRIMITIVES } + ( Float64 Float32 -> Float64 ) __@ADD ;
:!!! { __@PRIMITIVES } - ( Float64 Float64 -> Float64 ) __@SUB ;
:!!! { __@PRIMITIVES } - ( Float32 Float64 -> Float64 ) __@SUB ;
:!!! { __@PRIMITIVES } - ( Float64 Float32 -> Float64 ) __@SUB ;
:!!! { __@PRIMITIVES } * ( Float64 Float64 -> Float64 ) __@MUL ;
:!!! { __@PRIMITIVES } * ( Float32 Float64 -> Float64 ) __@MUL ;
:!!! { __@PRIMITIVES } * ( Float64 Float32 -> Float64 ) __@MUL ;
:!!! { __@PRIMITIVES } / ( Float64 Float64 -> Float64 ) __@DIV ;
:!!! { __@PRIMITIVES } / ( Float32 Float64 -> Float64 ) __@DIV ;
:!!! { __@PRIMITIVES } / ( Float64 Float32 -> Float64 ) __@DIV ;
:!!! { __@PRIMITIVES } / ( UnsignedInt UnsignedInt -> Float64 ) __@DIV ;
:!!! { __@PRIMITIVES } / ( SignedInt SignedInt -> Float64 ) __@DIV ;
:!!! { __@PRIMITIVES } / ( SignedInt UnsignedInt -> Float64 ) __@DIV ;
:!!! { __@PRIMITIVES } / ( UnsignedInt SignedInt -> Float64 ) __@DIV ;
