Option ~> T ~> {
	Some => T
	None
}

---
Maps a Boolean to an Option, where `false` becomes None, and `true` becomes
`when_true`.
---
from_bool :: true -> when_true -> Option.Some when_true
from_bool :: false -> Option.None

---
Maps an Option to a Boolean, where Some becomes `false` and None becomes
`true`.

For the inverse operation, see `is_some`.
---
is_none :: Option.Some -> false
is_none :: Option.None -> true

---
Maps an Option to a Boolean, where Some becomes `true` and None becomes
`false`.

For the inverse operation, see `is_none`.
---
is_some :: Option.Some -> true
is_some :: Option.None -> false

---
Maps an Option to its inner value, if Some, or a fallback value, if None. There
is no requirement at this level that the inner value of the Option and the
value of `fallback` are of the same type, mostly because the type system
currently can't express such a requirement. However, downstream callsites will
almost certainly expect congruence, meaning such enforcement usually happens
elsewhere in the callgraph anyway.

If `fallback` should be a dynamic value (i.e. requires a function call), use
`or_with` instead.
---
or :: val(Option.Some) -> val
or :: Option.None -> fallback -> fallback

---
Maps an Option to a Result, wrapping a Some value in Result.Ok when applicable,
and otherwise returning a Result.Err containing `when_none`.
---
must :: val(Option.Some) -> Result.Ok val
must :: Option.None when_none -> Result.Err when_none

---
Maps an Option to a Result, wrapping `when_some` in Result.Err and `when_none`
in Result.Ok based on the state of `it`. The inner value of the Some type is
ignored; to handle it, see `must` instead. Most callers should not pass Results
for `when_some` and `when_none` unless nested Results are desired.
---
must_not :: Option.Some -> when_some -> Result.Err when_some
must_not :: Option.None -> _ -> when_none -> Result.Ok when_none
