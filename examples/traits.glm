-- gluumy is copyfree software with no warranty, released under the CC0-1.0
-- public-domain-esque dedication found in COPYING in gluumy's source tree, or
-- at https://creativecommons.org/publicdomain/zero/1.0/

. std.io println

--- => denotes a shape, gluumy's catch-all for a bunch of related concepts:
--- structs, interfaces, traits, bounds. They are made up of members, which must
--- have a type (explicit or implicit) and an underlying implementation to be valid
--- at runtime, however those parts may be provided in any order, allowing shapes
--- to fill the role of interfaces despite otherwise operating most like structs.
---
--- In this example, we're defining a partial shape, where a member `repr` is a
--- function accepting an unbound (meaning not used in the function body) argument
--- of the special type Self which will be expected to return the type :String
--- (unlike Ruby or Elixir, colon prefixes are just an alias to the Core library
--- rather than symbols, and desugar to `core.`). Since types are not, themselves,
--- returnable values in gluumy, the type checker knows this is a definition and
--- not an implementation, and we'll have to provide such an implementation
--- elsewhere.
ExampleRepresentable =>
	repr { Self } -> :String

ExampleDebuggable =>
	-- Simply because it's confusing to allow otherwise, debug-printing an object
	-- requires that it be printable in non-debug form, too. This also makes a
	-- convenient opportunity to show off shape interdependence. `<=` allows
	-- merging in one shape definition per line, with the ultimate semantics
	-- bearing much similarity to TypeScript's `&` operator.
	<= ExampleRepresentable

	-- This default implementation will be derived assuming its shape dependencies
	-- are fulfilled, and otherwise, an override must be provided matching whatever
	-- signature this returns
	--
	-- The first argument to any method will be of type Self, which is always
	-- type-inferred (no need to annotate `self: Self` here), but in this case,
	-- we're further mandating that all properties within the shape of `self`
	-- fulfill ExampleDebuggable themselves. If all members of a shape fulfill
	-- a shape, so does the shape itself.
	--
	-- If we really wanted to be explicit about Self here, we could (though the
	-- linter would complain) with `self(ExampleDebuggable Self)`
	repr_debug { self(ExampleDebuggable) } ->
		type_name =
			:reflect.type_name self
			|> :option.or "Shape"
		fields =
			-- indentations can continue the preceeding statement, which can
			-- greatly help readability (and allow splitting long function
			-- calls onto multiple lines). this also reduces the need for
			-- parentheses, because each line, unless followed by an indent, is
			-- considered a "complete thought" and evaluates (in a one-line
			-- version of this example, :shape.fields self would need to be
			-- wrapped in parentheses to treat it as a function call returning
			-- a single result, rather than as two separate arguments to
			-- :iter.map)
			:iter.map
				:shape.fields self
				{ ele } -> ele.repr_debug!
			|> :iter.join ", "

		:string.format "%s(%s)" type_name fields

Song =>
	-- By declaring this, the type checker will ensure we've fulfilled the shape
	-- requirements somewhere within this definition, since ExampleRepresentable
	-- contains only stubs, not implementations.
	<= ExampleRepresentable

	artist = :String
	album_artist = :Option :String
	title :String

	track = :Option =>
		num = :Natural
		total = :Natural

		-- We can fulfil traits without claiming to fulfil them with the "is"
		-- keyword. We'll get gnarlier error messages if the contracts ever change
		-- in the future, though, so generally "is" is encouraged.
		repr { (num total) } -> :string.format "Track %d/%d" num total


	repr { (title artist album_artist) } ->
		:string.format
			"%s by %s"
			title
			:option.or album_artist artist

-- this prints "Wandering Star by Portishead"
main { .. } ->
	Song <=>
		artist = "Portishead"
		title = "Wandering Star"
		track =
			:Option.Some
			=>
				num = 5
				total = 7
	|> println
